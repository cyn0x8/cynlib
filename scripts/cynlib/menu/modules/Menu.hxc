import flixel.FlxBasic;
import flixel.util.FlxTimer;

import funkin.PlayerSettings;
import funkin.input.Controls;
import funkin.modding.module.ScriptedModule;

typedef Menu = {
	data:Null<Dynamic>,
	
	container:Null<FlxBasic>,
	
	enabled:Bool,
	frozen:Bool,
	
	selection:Int,
	items:Array<Dynamic>,
	
	sizeX:Int,
	sizeY:Int,
	
	wrapX:Bool,
	wrapY:Bool,
	
	onEnter:Null<()->Void>,
	onExit:Null<()->Void>,
	onBack:Null<()->Void>,
	
	onUpdate:Null<(Float)->Void>,
	
	pushItems:(Array<Dynamic>)->Void,
	
	debounce:(Float)->Void,
	debounceTimer:Null<FlxTimer>,
	
	update:(Float)->Void,
	
	exists:Bool,
	destroy:()->Void
}

typedef MenuData = {
	data:Null<Dynamic>,
	
	container:Null<FlxBasic>,
	
	sizeX:Null<Int>,
	sizeY:Null<Int>,
	
	wrapX:Null<Bool>,
	wrapY:Null<Bool>,
	
	onEnter:Null<()->Void>,
	onExit:Null<()->Void>,
	onBack:Null<()->Void>,
	
	onUpdate:Null<(Float)->Void>
}

class CL_Menu extends ScriptedModule {
	public function new() {
		super("CL_Menu", -2147483648);
	}
	
	public function new_Menu(data:MenuData):Menu {
		if (data == null) {
			data = {};
		}
		
		var obj:Dynamic = {
			data: data.data == null ? {} : data.data,
			
			container: data.container,
			
			enabled: false,
			frozen: false,
			
			selection: 0,
			items: new Array(),
			
			wrapX: data.wrapX == null ? true : data.wrapX,
			wrapY: data.wrapY == null ? true : data.wrapY,
			
			onEnter: data.onEnter == null ? function():Void {} : data.onEnter,
			onExit: data.onExit == null ? function():Void {} : data.onExit,
			onBack: data.onBack == null ? function():Void {} : data.onBack,
			
			onUpdate: data.onUpdate == null ? function(elapsed:Float):Void {} : data.onUpdate,
			
			enabled: false
		};
		
		obj.sizeX = Std.int(data.sizeX == null ? 1 : Math.max(1, data.sizeX));
		obj.sizeY = Std.int(data.sizeY == null ? Math.max(1, obj.items.length) / obj.sizeX : Math.max(1, data.sizeY));
		
		obj.pushItems = function(items:Array<Dynamic>, autoEnable:Bool = true):Void {
			if (!obj.exists) {
				return;
			}
			
			for (item in items) {
				if (items.length >= obj.sizeX * obj.sizeY) {
					return;
				}
				
				obj.items.push(item);
				
				item.parent = obj;
				if (autoEnable) {
					item.enabled = true;
				}
				
				if (obj.items.length == 1) {
					item.focused = true;
					item.onFocus(null);
				}
			}
		};
		
		obj.debounce = function(duration:Float):Void {
			if (!obj.exists || duration < 0) {
				return;
			}
			
			obj.enabled = false;
			
			if (obj.debounceTimer != null) {
				obj.debounceTimer._timeCounter = 0;
				obj.debounceTimer.time = Math.max(obj.debounceTimer.time, duration);
			} else {
				obj.debounceTimer = new FlxTimer().start(duration, function():Void {
					obj.enabled = true;
					
					obj.debounceTimer = null;
				});
			}
		};
		
		obj.update = function(elapsed:Float):Void {
			if (!obj.exists || obj.frozen) {
				return;
			}
			
			if (obj.enabled && obj.items.length > 0) {
				var controls:Controls = PlayerSettings.player1.controls;
				if (controls != null) {
					if (controls.BACK) {
						obj.onBack();
					} else if (controls.check("accept", 2)) { // JUST_PRESSED
						obj.items[obj.selection].onPress();
					} else if (controls.check("accept", -1)) { // JUST_RELEASED
						obj.items[obj.selection].onRelease();
					} else {
						var prevSelection:Int = obj.selection;
						var prevItem:Dynamic = obj.items[prevSelection];
						
						var directions:Array<Bool> = [
							controls.UI_LEFT_P,
							controls.UI_DOWN_P,
							controls.UI_UP_P,
							controls.UI_RIGHT_P
						];
						
						if (prevItem.autoNavigate) {
							if (obj.sizeX > 1) {
								if (directions[0]) {
									obj.selection -= 1;
								}
								
								if (directions[3]) {
									obj.selection += 1;
								}
								
								var row:Int = Std.int(Math.floor(prevSelection / obj.sizeX)) * obj.sizeX;
								if (obj.wrapX) {
									obj.selection = row + obj.selection % obj.sizeX;
								} else {
									obj.selection = Std.int(Math.min(Math.max(obj.selection, row), row + obj.sizeX - 1));
								}
							}
							
							if (obj.sizeY > 1) {
								if (directions[2]) {
									obj.selection -= obj.sizeX;
								}
								
								if (directions[1]) {
									obj.selection += obj.sizeX;
								}
								
								var column:Int = prevSelection % obj.sizeX;
								if (obj.wrapY) {
									obj.selection = (obj.selection + obj.items.length) % obj.items.length;
								} else {
									obj.selection = Std.int(Math.min(Math.max(obj.selection, column), obj.sizeX * (obj.sizeY - 1) + column));
								}
							}
						}
						
						var directionTrigger:Bool = false;
						for (direction in directions) {
							if (direction) {
								directionTrigger = true;
								break;
							}
						}
						
						if (directionTrigger) {
							prevItem.onDirection(directions);
						}
						
						var curItem:Dynamic = obj.items[obj.selection];
						if (prevSelection != obj.selection) {
							prevItem.focused = false;
							curItem.focused = true;
							
							prevItem.onUnfocus(curItem);
							curItem.onFocus(prevItem);
						}
					}
				}
			}
			
			obj.onUpdate(elapsed);
			
			for (item in obj.items) {
				if (item.exists) {
					item.onUpdate(elapsed);
				}
			}
		};
		
		obj.destroy = function():Void {
			obj.data = null;
			
			obj.container = null;
			
			obj.enabled = false;
			obj.frozen = true;
			
			obj.selection = -1;
			while (obj.items.length > 0) {
				obj.items.pop().destroy();
			}
			
			obj.sizeX = -1;
			obj.sizeY = -1;
			
			obj.wrapX = false;
			obj.wrapY = false;
			
			obj.onEnter = null;
			obj.onExit = null;
			obj.onBack = null;
			
			obj.onUpdate = null;
			
			if (obj.debounceTimer != null) {
				obj.debounceTimer.cancel();
				obj.debounceTimer.destroy();
				obj.debounceTimer = null;
			}
			
			obj.exists = false;
			
			alive.remove(obj);
		};
		
		alive.push(obj);
		
		return obj;
	}
	
	private var alive:Array<Menu> = new Array();
	
	override public function onUpdate(event:UpdateScriptEvent):Void {
		for (menu in alive) {
			menu.update(event.elapsed);
		}
	}
	
	override public function onDestroy(event:ScriptEvent):Void {
		for (menu in alive) {
			menu.destroy();
		}
	}
}